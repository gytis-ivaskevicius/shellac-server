# CLAP grammar (Command Line Argument Parse)

**EARLY DRAFT STATE**

## Introduction

A significant part of what makes up completion functions is just lists of options with their descriptions. This duplicates the content of `--help` output and man pages. It needs to be maintained separately for bash, zsh, fish etc and is in a form that is specific to completion - it can't be used for syntax-highlighting, correction, look ahead prompts or whatever other features someone might imagine. It would also be better for this information to be maintained as part of the upstream project to avoid inaccuracies due to version skew.

Where upstream projects do include completion functions, they sometimes write them for bash and only support zsh via the `bashcompinit` compatibility layer. This dumbs down zsh completion to the level of bash. Shell developers should have the freedom to innovate and come up with inventive new interactive features.

Upstream projects are increasingly coming up with ways to provide shell completions via special options such as in the recent case of clang. The trouble with this is that every project handles this in a slightly different way making it a mess to configure them all. And often solutions are developed by people who don't have a lot of experience with completion or who make bash-centric assumptions.

The idea here is to define a DSL for the description of the arguments, options and structure of command-line arguments for a particular command. These could be placed in text files under `/usr/share` and used by any shell, shell plugin or other program with an interest in them.

## Format

We want to specify a parse grammar but it needs to be augmented with additional information like descriptions and tags (which specify what is to be completed). We want it to be concise but powerful enough to handle nearly everything we might encounter on a command-line. While the details below might hint otherwise, it should not be necessary for descriptions to be a dense forest of regular expressions: most arguments are bounded by shell word boundaries and simple delimiters.

Parsing goes left-right up to the cursor. And the set of possible states at this stage indicates things to be completed. Parsing should also proceed to the right of the cursor which might further limit the sets, mainly by manipulating sentinel values.

The requirements are in some ways quite different to typical parsing problems such as for a compiler. We don't need all the tokens. An ambiguous parse is not a problem: for completion we have, by definition, an incomplete line. This rules out a PEG parser. A more likely approach is a initial level of recursion but bottom-up style pattern matching at a lower level.

```
{ … } blocks of alternatives (no alternation operator needed)
<…>   delimits tags these correspond to groups of things that might be completed
[…]   descriptions and headings
/…/   regex for consumed characters
(…)   sentinel conditions
=>    concatenation (continuation in next argument)
->    concatenation (splitting the current argument)
$     named sequence (like <…> in BNF), can be scoped
@     macro or function invocation, can also be scoped
=     assign a sequence to a name, newline terminates but blocks and trailing operators allow continuation
```

Alternation is the default within `{…}` blocks, each alternative can only be passed once unless followed by `(*)`.

The following is a sort of example to demonstrate usage

```
version: 0.0                              # declare grammar specification version
counters: 4
arguments: ($opts | -x <user>)* => <arg0> => <arg1> => $arg2

sections:
  opts = {                             # define a named sequence
    /-([a-z])|--([a-z\-]{2,})/         # match and ignore unknown options

    f [0] (0;=0;+1)                    # short option with reference to description
    l [1] (1;=0;+1)
    long [1] (2;=0;+1)
    r [2]                              # repeatable option (no conditions)
    v [3] (3;<3;+1)                    # repeatable with maximum
    y [4] (4;!0;)                      # option excluded by sentinel
    o [5] (4;;-1)
    opt [5] (4;;+1)                    # subgroup incrementing a sentinel
    do [6]
    undo [7]
  }

  arg2:
    - snake_case
    - joined_words

definitions:
  arg0: exec("$arg --list-args")  # shell-command to list arguments:descriptions
  arg1: complete("$arg --list-args")  # Refer to an external definition

desc:
  1:
    default: "Hilfe ausgeben"       # TBD: mapping of localized descriptions
  2:
    default: "Hilfe ausgeben"       # TBD: mapping of localized descriptions
    de_DE: "Hilfe ausgeben"         # TBD: mapping of localized descriptions

### Tags and Descriptions

Common tags might be predefined, e.g.
* options
* processes
* files
* directories
* users
* hosts
For common tags, you can elide the description. We'll need ways to provide options to certain tags like file extensions to be completed. Tags also come with predefined regexes for characters to be consumed.

The grammar files also have the potential to allow for localization of descriptions.
Zsh has conventions on how to represent default values and units. These could have explicit syntax.
May also be useful to be able to tag the key verb in per-match descriptions. Sorting matches by it could be useful.

### Regular Expressions

Regex are full match by default. Simply add .* to match a subset. To allow argument grouping (i.e. tar -xvf), capture groups are used to find argument boundaries.

